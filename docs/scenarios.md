# Scenarios System

## Overview

The Scenarios System provides JSON-based data injection for DDS Publisher applications, enabling scenario-driven testing and simulation without modifying source code. It allows publishers to read mission data from JSON files, making it easy to test different scenarios, replay recorded data, and simulate various operational conditions.

## Purpose

The scenarios system enables:

- **Scenario-Based Testing**: Test publishers with predefined data scenarios
- **Data Replay**: Replay recorded mission data
- **Simulation Support**: Simulate various operational conditions
- **Development Flexibility**: Test without active DDS infrastructure
- **Data Validation**: Validate publisher behavior with known data sets

## Architecture

### Components

1. **Scenario Files** (`scenarios/*.json`)
   - JSON files containing data arrays
   - One file per IDL module
   - Structured data matching IDL types

2. **JSON Patcher** (`scripts/py/json_reading_patcher.py`)
   - Modifies PublisherApp files
   - Injects JSON reading code
   - Replaces hardcoded data assignments

3. **IDL Patcher** (`scripts/py/idl_default_data_patcher.py`)
   - Creates AUTOGENERATED blocks
   - Generates default data assignments
   - Prerequisite for JSON patcher

4. **nlohmann/json Library** (`include/nlohmann/json.hpp`)
   - C++ JSON parsing library
   - Header-only implementation
   - Automatically downloaded if missing

## How It Works

### 1. Scenario File Structure

Each scenario file corresponds to an IDL module and contains an array of data objects:

**Example: scenarios/CoreData.json**
```json
[
  {
    "latitude": 40.00526489,
    "longitude": 32.8597,
    "altitude": 1100.0,
    "time_seconds": 1761461216,
    "time_nano_seconds": 0,
    "speed_mps": 255.0,
    "orientation_degrees": 90
  },
  {
    "latitude": 40.00501944,
    "longitude": 32.86743947,
    "altitude": 1116.5,
    "time_seconds": 1761461218,
    "time_nano_seconds": 123456789,
    "speed_mps": 266.0,
    "orientation_degrees": 95
  }
]
```

**Key Characteristics:**
- Array of objects (each object is one sample)
- Field names match IDL struct field names exactly
- Data types match IDL types (double, float, long, etc.)
- Can contain any number of samples

### 2. Patching Workflow

The patching process transforms PublisherApp files to read from JSON:

#### Step 1: IDL Patcher (Prerequisite)

**Purpose**: Creates AUTOGENERATED blocks with default data

**Execution**:
```bash
python3 scripts/py/idl_default_data_patcher.py
```

**Result**: PublisherApp files contain:
```cpp
// --- BEGIN AUTOGENERATED IDL PATCH (v9) ---
sample_.latitude(37.7749);
sample_.longitude(-122.4194);
sample_.altitude(100.0f);
// ... more assignments
// --- END AUTOGENERATED IDL PATCH (v9) ---
```

#### Step 2: JSON Patcher

**Purpose**: Replaces AUTOGENERATED blocks with JSON reading code

**Execution**:
```bash
python3 scripts/py/json_reading_patcher.py
```

**Result**: PublisherApp files contain:
```cpp
// JSON file reading code
std::ifstream json_file("scenarios/CoreData.json");
nlohmann::json scenario_data;
json_file >> scenario_data;

// Iterate through scenario data
for (const auto& data_obj : scenario_data) {
    sample_.latitude(data_obj["latitude"].get<double>());
    sample_.longitude(data_obj["longitude"].get<double>());
    // ... more assignments from JSON
    writer->write(&sample_);
}
```

### 3. File Matching

The JSON patcher matches PublisherApp files with scenario files:

**Matching Logic:**
1. Extracts module name from PublisherApp filename
   - `CoreDataPublisherApp.cxx` → `CoreData`
2. Constructs scenario file path
   - `scenarios/CoreData.json`
3. Verifies file exists
4. Applies patch if file exists

**Supported Modules:**
- CoreData → `scenarios/CoreData.json`
- CoreData2 → `scenarios/CoreData2.json`
- CoreData3 → `scenarios/CoreData3.json`
- CoreData4 → `scenarios/CoreData4.json`
- Intelligence → `scenarios/Intelligence.json`
- Messaging → `scenarios/Messaging.json`

### 4. JSON Library Integration

The nlohmann/json library is automatically integrated:

**Location**: `include/nlohmann/json.hpp`

**Download**: Automatically downloaded by `generate_idl_code.sh` if missing

**Usage in Generated Code**:
```cpp
#include <nlohmann/json.hpp>
using json = nlohmann::json;
```

**Features**:
- Header-only library (no linking required)
- Modern C++ API
- Type-safe parsing
- Exception handling

## Technologies Used

### Core Technologies

- **JSON**: JavaScript Object Notation for data format
- **nlohmann/json**: C++ JSON parsing library
- **Python**: Patching scripts
- **C++17**: Modern C++ features

### Supporting Technologies

- **IDL Parser**: For understanding data structures
- **Regex**: For code pattern matching
- **File I/O**: For reading JSON files

## Requirements

### Prerequisites

- **IDL Patcher**: Must be run first to create AUTOGENERATED blocks
- **JSON Files**: Scenario files must exist in `scenarios/` directory
- **JSON Library**: nlohmann/json must be available (auto-downloaded)

### File Structure

See `scenarios.mdd` for the complete file structure diagram.

## Usage

### Complete Workflow

#### 1. Create Scenario Files

Create JSON files in `scenarios/` directory matching your IDL modules:

```bash
cd scenarios
# Create or edit CoreData.json
nano CoreData.json
```

#### 2. Run IDL Patcher

```bash
python3 scripts/py/idl_default_data_patcher.py
```

This creates AUTOGENERATED blocks in PublisherApp files.

#### 3. Run JSON Patcher

```bash
python3 scripts/py/json_reading_patcher.py
```

This replaces AUTOGENERATED blocks with JSON reading code.

#### 4. Build Publishers

```bash
bash scripts/sh/build_idl_modules.sh
```

Or from project root:
```bash
cd scripts/sh
bash build_idl_modules.sh
```

Or build individual modules:
```bash
cd IDL/CoreData_idl_generated/build
cmake ..
make
```

#### 5. Run Publisher

```bash
cd IDL/CoreData_idl_generated/build
./CoreDatamain publisher
```

The publisher will read data from `scenarios/CoreData.json` and publish each sample.

### Scenario File Format

#### Basic Structure

```json
[
  {
    "field1": value1,
    "field2": value2,
    ...
  },
  {
    "field1": value1,
    "field2": value2,
    ...
  }
]
```

#### Data Types

**Numbers:**
- `double`: `39.9334`
- `float`: `1500.0`
- `long`: `1730352000`
- `unsigned long`: `500000000`
- `short`: `90`

**Strings:**
- `string`: `"UAV_MODUL_01"`

**Booleans:**
- `boolean`: `true` or `false`

#### Field Name Matching

Field names in JSON must exactly match IDL struct field names:

**IDL Definition:**
```idl
struct FlatCoreData {
    double latitude;
    double longitude;
    float altitude;
};
```

**JSON File:**
```json
{
  "latitude": 39.9334,
  "longitude": 32.8597,
  "altitude": 1500.0
}
```

### Creating Scenario Files

#### Method 1: Manual Creation

Create JSON files manually using a text editor:

```bash
cd scenarios
nano CoreData.json
```

#### Method 2: From Recorded Data

Convert recorded DDS data to JSON format:

```bash
# Parse monitor output and convert to JSON
monitor_output | parse_to_json > scenarios/CoreData.json
```

#### Method 3: From Database

Export data from database to JSON:

```bash
# Example with database export
database_export --format json --module CoreData > scenarios/CoreData.json
```

### Testing Scenarios

#### Single Scenario Test

```bash
# Run publisher with specific scenario
cd IDL/CoreData_idl_generated/build
./CoreDatamain publisher
```

#### Multiple Scenarios

Run multiple publishers with different scenarios:

```bash
# Terminal 1
cd IDL/CoreData_idl_generated/build
./CoreDatamain publisher

# Terminal 2
cd IDL/Intelligence_idl_generated/build
./Intelligencemain publisher

# Terminal 3
cd IDL/Messaging_idl_generated/build
./Messagingmain publisher
```

## Integration Points

### With IDL System

- Scenario files match IDL module names
- Field names must match IDL struct fields
- Data types must be compatible

### With Build System

- JSON library is included in build
- No additional linking required (header-only)
- CMake automatically finds JSON header

### With Demo System

- Demo server can load scenario files for simulation
- Scenarios enable testing without DDS infrastructure
- Supports `DDS_ONLY=false` mode

### With Monitoring System

- Monitor can receive data from scenario-driven publishers
- Scenarios enable reproducible testing
- Data validation through scenario comparison

## Troubleshooting

### JSON Parser Errors

**Problem**: Publisher fails to parse JSON file

**Solutions**:
1. **Check JSON Syntax**: Validate JSON syntax (use JSON validator)
2. **Verify File Path**: Ensure JSON file exists at expected path
3. **Check Field Names**: Verify field names match IDL struct fields exactly
4. **Check Data Types**: Ensure JSON types match IDL types
5. **File Permissions**: Verify read permissions on JSON file

### Missing Scenario Files

**Problem**: JSON patcher skips files or publisher can't find JSON

**Solutions**:
1. **Create Missing Files**: Create JSON files for all modules
2. **Check File Names**: Ensure filenames match module names exactly
3. **Verify Location**: JSON files must be in `scenarios/` directory
4. **Check Working Directory**: Publisher must run from correct directory

### Type Mismatches

**Problem**: JSON data types don't match IDL types

**Solutions**:
1. **Review IDL Definition**: Check expected types in IDL file
2. **Fix JSON Types**: Update JSON to match IDL types
3. **Type Conversion**: JSON patcher handles some conversions automatically
4. **Validation**: Validate JSON against IDL schema if available

### Patching Order Issues

**Problem**: JSON patcher doesn't find AUTOGENERATED blocks

**Solutions**:
1. **Run IDL Patcher First**: IDL patcher must run before JSON patcher
2. **Check Block Markers**: Verify AUTOGENERATED blocks exist
3. **Re-run Patchers**: Run IDL patcher, then JSON patcher in order
4. **Check File Status**: Ensure PublisherApp files weren't manually modified

## Best Practices

### Scenario Design

1. **Realistic Data**: Use realistic data values for testing
2. **Edge Cases**: Include edge cases and boundary conditions
3. **Multiple Samples**: Include multiple samples for thorough testing
4. **Documentation**: Document scenario purpose and expected behavior

### File Management

1. **Version Control**: Commit scenario files to version control
2. **Naming Convention**: Use consistent naming (ModuleName.json)
3. **Organization**: Organize scenarios by purpose or test case
4. **Backup**: Keep backups of important scenarios

### Testing Strategy

1. **Incremental Testing**: Test with small scenarios first
2. **Validation**: Validate JSON against IDL structure
3. **Reproducibility**: Use scenarios for reproducible testing
4. **Coverage**: Create scenarios covering all use cases

<<<<<<< HEAD
## Project Structure

See `scenarios.mdd` for the complete project structure and operation diagrams.
=======
<<<<<<< HEAD

## Operation Diagram

```
┌─────────────────────────────────────────────────────────────┐
│              Scenario Files                                  │
│  scenarios/CoreData.json                                   │
│  scenarios/Intelligence.json                               │
│  scenarios/Messaging.json                                  │
└────────────────────┬────────────────────────────────────────┘
                     │ JSON Patcher
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              PublisherApp Modification                      │
│  - Replaces AUTOGENERATED blocks                           │
│  - Adds JSON reading code                                  │
│  - Includes nlohmann/json                                 │
└────────────────────┬────────────────────────────────────────┘
                     │ Build
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              Publisher Executable                            │
│  - Reads scenarios/*.json                                  │
│  - Parses JSON data                                        │
│  - Publishes samples                                       │
└────────────────────┬────────────────────────────────────────┘
                     │ DDS Topics
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              DDS Subscribers                                │
│  - Receive scenario data                                   │
│  - Process and display                                     │
└─────────────────────────────────────────────────────────────┘
```
=======
## Project Structure

See `scenarios.mdd` for the complete project structure and operation diagrams.
>>>>>>> 4094b194 (directory managemend upgraded, scripts renamed, docs updated)
>>>>>>> 9f27b6be (directory managemend upgraded, scripts renamed, docs updated)

## Notes

- Scenario files are the source of truth for test data
- JSON patcher must run after IDL patcher (order is critical)
- Scenario files enable testing without active DDS infrastructure
- JSON library is header-only (no linking required)
- Scenario data is published sequentially (one sample per iteration)
- The system supports both real DDS data and scenario-based simulation
